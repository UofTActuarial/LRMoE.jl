var documenterSearchIndex = {"docs":
[{"location":"dummytest/#Dummy","page":"Dummy","title":"Dummy","text":"","category":"section"},{"location":"dummytest/","page":"Dummy","title":"Dummy","text":"dummy","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"author: \"Spark Tseung\" title: \"Simulated data in LRMoE.jl\" –-","category":"page"},{"location":"examples/sim_data/simulate_data/#Introduction","page":"Simulated Data","title":"Introduction","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"This document contains the data generation process for the dataset LRMoEDemoData included  in the LRMoE.jl package. This also serves as an example of using the sim_dataset function  included in the package.","category":"page"},{"location":"examples/sim_data/simulate_data/#Data-Simulation","page":"Simulated Data","title":"Data Simulation","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/#Complete-Data","page":"Simulated Data","title":"Complete Data","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"Suppose there is an auto-insurance company with two lines of business, with a total of 10,000 policies.  The policyholder information includes sex (1 for Male and 0 for Female), driver's age (with range 20 - 80),  car age (with range 0 - 10), and region (1 for urban and 0 for rural).  We assume all covariates are uniformly and independently drawn at random.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"# Random seed for reproducible results\nRandom.seed!(7777)\nsample_size = 10000\n\nintercept = fill(1.0, sample_size)\nsex = rand(Binomial(1, 0.50), sample_size)\naged = rand(Uniform(20, 80), sample_size)\nagec = rand(Uniform(0, 10), sample_size)\nregion = rand(Binomial(1, 0.50), sample_size)\n\nX = DataFrame(intercept = intercept, sex= sex, \n              aged = aged, agec = agec, region = region)","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"The first few rows of X are shown below.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"6×5 DataFrame\n│ Row │ intercept │ sex   │ aged    │ agec      │ region │\n│     │ Float64   │ Int64 │ Float64 │ Float64   │ Int64  │\n├─────┼───────────┼───────┼─────────┼───────────┼────────┤\n│ 1   │ 1.0       │ 1     │ 56.4367 │ 3.3857    │ 1      │\n│ 2   │ 1.0       │ 1     │ 29.7025 │ 2.31892   │ 1      │\n│ 3   │ 1.0       │ 1     │ 33.4796 │ 8.61125   │ 0      │\n│ 4   │ 1.0       │ 0     │ 38.7478 │ 2.88865   │ 1      │\n│ 5   │ 1.0       │ 1     │ 47.348  │ 9.01135   │ 0      │\n│ 6   │ 1.0       │ 1     │ 54.7017 │ 0.0306372 │ 0      │","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"For simplicity, we assume there are two latent risk classes: low (L) and high (H).  The characteristics for the high-risk class are male, young age, old car age and urban region.  This is specified by the following matrix of logit regression coefficients,  where the second row represents the reference class.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"α = [-0.5 1.0 -0.05 0.1 1.25;\n      0.0 0.0   0.0 0.0  0.0]","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"We consider a two-dimensional response: claim frequency from the first business line,  and claim severity from the second business line.  For demonstration purposes and for simplicity, we don't consider the same business line to avoid the complication  where zero frequency necessarily implies zero severity.  The component distributions and their parameters are specified as follows.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"comp_dist = [PoissonExpert(6.0)         ZIGammaCountExpert(0.20, 30, 0.50);\n             LogNormalExpert(4.0, 0.3)  InverseGaussianExpert(20, 20)]","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"The LRMoE.jl package includes a simulator. Given the covariates and parameters defined above,  we can directly simulate a dataset.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"Y_complete = LRMoE.sim_dataset(α, X, comp_dist)","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"The simulated values are plotted as follows.  For each dimension of Y, the histogram is relatively well separated as two components.  This is more or less done on purpose to demonstrate that the fitting procedure can identify the true model  when it is known.  In practice, we are usually less concerned of the underlying data generating distribution,  as long as the LRMoE model provides a reasonable fit of data.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"(Image: )","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"(Image: )","category":"page"},{"location":"examples/sim_data/simulate_data/#Truncation-and-Censoring","page":"Simulated Data","title":"Truncation and Censoring","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"One distinct feature of LRMoE is dealing with data truncation and censoring,  which is common in insurance contexts.  Consequently, instead of one single number for each dimension d, a tuple (tl_d, yl_d, yu_d, tu_d) is required,   where tl_d/tu_d are the lower/upper bounds of truncation, and yl_d/yu_d are the lower/upper bounds of censoring.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"For illustration purposes, we assume the dataset is subject to the following truncation and censoring.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"Index Y_complete[:,1] Y_complete[:,2]\n1-6000 No truncation  or censoring No truncation  or censoring\n6001-8000 No truncation  or censoring Left Truncated at 5\n8001-10000 No truncation  or censoring Right Censored at 100","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"# First block: 1~6000\nX_obs = X[1:6000,:]\n\ntl_1 = fill(0.0, 6000)\nyl_1 = Y_complete[1:6000, 1]\nyu_1 = Y_complete[1:6000, 1]\ntu_1 = fill(Inf, 6000) \n\ntl_2 = fill(0.0, 6000)\nyl_2 = Y_complete[1:6000, 2]\nyu_2 = Y_complete[1:6000, 2]\ntu_2 = fill(Inf, 6000) \n\n# Second block: 6001~8000\nkeep_idx = Y_complete[6001:8000,2] .>=  5\nkeep_length = sum(keep_idx) # 1837 out of 2000\n\nappend!(X_obs, X[6001:8000,:][keep_idx,:])\n\nappend!(tl_1, fill(0.0, keep_length))\nappend!(yl_1, Y_complete[6001:8000, 1][keep_idx])\nappend!(yu_1, Y_complete[6001:8000, 1][keep_idx])\nappend!(tu_1, fill(Inf, keep_length))\n\ny_temp = Y_complete[6001:8000, 2][keep_idx]\nappend!(tl_2, fill(5.0, keep_length))\nappend!(yl_2, Y_complete[6001:8000, 2][keep_idx])\nappend!(yu_2, Y_complete[6001:8000, 2][keep_idx])\nappend!(tu_2, fill(Inf, keep_length))\n\n# Third block: 8001~10000\nappend!(X_obs, X[8001:10000,:])\n\nappend!(tl_1, fill(0.0, 2000))\nappend!(yl_1, Y_complete[8001:10000, 1])\nappend!(yu_1, Y_complete[8001:10000, 1])\nappend!(tu_1, fill(Inf, 2000))\n\ny_temp = Y_complete[8001:10000, 2]\ncensor_idx = y_temp .>= 100.0 # 21 out of 2000\nyl_temp = copy(y_temp)\nyl_temp[censor_idx] .= 100\nyu_temp = copy(y_temp)\nyu_temp[censor_idx] .= Inf\nappend!(tl_2, fill(0.0, 2000))\nappend!(yl_2, yl_temp)\nappend!(yu_2, yu_temp)\nappend!(tu_2, fill(Inf, 2000))\n\n# Put things together\nY_obs = DataFrame(tl_1 = tl_1, yl_1 = yl_1, yu_1 = yu_1, tu_1 = tu_1,\n                  tl_2 = tl_2, yl_2 = yl_2, yu_2 = yu_2, tu_2 = tu_2)","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"As a result of truncating Y_complete[:,2], 163 rows are discarded,  leaving 9837 observations available for model fitting. Sample data points are show below.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"3×4 DataFrame\n│ Row │ tl_1    │ yl_1    │ yu_1    │ tu_1    │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┤\n│ 1   │ 0.0     │ 6.0     │ 6.0     │ Inf     │\n│ 2   │ 0.0     │ 8.0     │ 8.0     │ Inf     │\n│ 3   │ 0.0     │ 7.0     │ 7.0     │ Inf     │","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"3×4 DataFrame\n│ Row │ tl_2    │ yl_2    │ yu_2    │ tu_2    │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┤\n│ 1   │ 0.0     │ 89.0332 │ 89.0332 │ Inf     │\n│ 2   │ 5.0     │ 37.4133 │ 37.4133 │ Inf     │\n│ 3   │ 0.0     │ 100.0   │ Inf     │ Inf     │","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"We will export both the complete and incomplete datasets to the LRMoE.jl package.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Simulated Data","title":"Simulated Data","text":"@save \"X_complete.jld2\" X\n@save \"Y_complete.jld2\" Y_complete\n@save \"X_obs.jld2\" X_obs\n@save \"Y_obs.jld2\" Y_obs","category":"page"},{"location":"framework/#Modelling-Framework","page":"Modelling Framework","title":"Modelling Framework","text":"","category":"section"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"The LRMoE model is formulated as follows. Let (mathbfx_i mathbfy_i) i = 1 2 dots n denote a set of observations, where mathbfx_i denotes the covariates and mathbfy_i the response(s).","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Given mathbfx_i, the i-th observation is classified into one of g latent classes by the so-called logit gating function. The probability of belonging to the j-th latent class is given by","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"pi_j(mathbfx_i mathbfalpha) = fracexp (mathbfalpha_j^T mathbfx_i)sum_j=1^g exp (mathbfalpha_j^T mathbfx_i) quad j = 1 2 dots g-1","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"For model identifiability reasons, we assume mathbfalpha_g = mathbf0 which corresponds to the reference class.","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Conditional on the latent class j, the distribution of the response mathbfy_i is given by an expert function with density","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"f_j(mathbfy_i mathbfpsi_j) = prod_d=1^D f_jd(mathbfy_id mathbfpsi_jd)","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"where we assume conditional independence of dimensions 1 2 dots D of mathbfy_i, if it is a vector of responses.","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"The likelihood function is therefore","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"L(mathbfalpha mathbfpsi mathbfx mathbfy) = prod_i=1^n left sum_j=1^g pi_j(mathbfx_i mathbfalpha) f_j(mathbfy_i mathbfpsi_j) right","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Notice that the parameters mathbfpsi_j do not involve regression on the covariates mathbfx_i, hence the model is termed as reduced. For an introduction to the general mixture-of-experts models, see e.g. here.","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Fung et al. (2019) have shown that such simplification of model structure will not reduce its flexibility, and will significantly reduce the computation efforts in model inference. The parameters to estimate are the regression coefficients mathbfalpha_j and parameters of the expert functions mathbfpsi_j, which is implemented by the standard Expectation-Conditional-Maximization algorithm (details omitted).","category":"page"},{"location":"experts/#Expert-Functions","page":"Expert Functions","title":"Expert Functions","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"The LRMoE package supports a collection of distributions commonly used for modelling insurance claim frequency and severity.","category":"page"},{"location":"experts/#Type-Hierarchy","page":"Expert Functions","title":"Type Hierarchy","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Expert functions are implemented as subtypes of the AnyExpert type in this package. A good number of expert functions are simply wrappers around the UnivariateDistribution type in Distributions.jl (details here), and functions such as pdf and cdf are also directly using those in Distributions.jl.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Specific to actuarial application, a collection of commonly used distributions are also included in this package, e.g. Burr, GammaCount, etc. See below for details.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Expert functions can be defined either on the real line, or only on nonnegative values (as is usually the case for actuarial loss modelling).","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"# Abstract type: support of expert function\nabstract type ExpertSupport end\nstruct RealValued <: ExpertSupport end\nstruct NonNegative <: ExpertSupport end","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Considering zero inflation is prominant in many actuarial applications, expert functions can be either zero-inflated or not, provided that they are supported only on nonnegative values.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"# Abstract type: whether the expert is zero-inflated\nabstract type ZeroInflation end\nstruct ZI <: ZeroInflation end\nstruct NonZI <: ZeroInflation end","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Each expert function is a univariate distribution (see here for UnivariateDistribution in Distributions.jl), with appropriate indication of support and zero inflation. ","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"# Abstract type: AnyExpert\nabstract type AnyExpert{s<:ExpertSupport, z<:ZeroInflation, d<:UnivariateDistribution} end\n# Discrete or Continuous\nconst DiscreteExpert{s<:ExpertSupport, z<:ZeroInflation} = \n                AnyExpert{s, z, DiscreteUnivariateDistribution}\nconst ContinuousExpert{s<:ExpertSupport, z<:ZeroInflation} = \n                AnyExpert{s, z, ContinuousUnivariateDistribution}\n# Real-valued expert distributions\nconst RealDiscreteExpert = DiscreteExpert{RealValued, NonZI}\nconst RealContinuousExpert = ContinuousExpert{RealValued, NonZI}\n# Nonnegative-valued expert distributions\nconst NonNegDiscreteExpert{z<:ZeroInflation} = DiscreteExpert{NonNegative, z}\nconst NonNegContinuousExpert{z<:ZeroInflation} = ContinuousExpert{NonNegative, z}\n# Zero-inflated\nconst ZIDiscreteExpert = NonNegDiscreteExpert{ZI}\nconst ZIContinuousExpert = NonNegContinuousExpert{ZI}\n# Non zero-inflated\nconst NonZIDiscreteExpert = NonNegDiscreteExpert{NonZI}\nconst NonZIContinuousExpert = NonNegContinuousExpert{NonZI}","category":"page"},{"location":"experts/#Discrete-Distributions-(Frequency-Modelling)","page":"Expert Functions","title":"Discrete Distributions (Frequency Modelling)","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"BinomialExpert\nNegativeBinomialExpert\nPoissonExpert","category":"page"},{"location":"experts/#LRMoE.BinomialExpert","page":"Expert Functions","title":"LRMoE.BinomialExpert","text":"BinomialExpert(n, p)\n\nPMF:\n\nP(X = k) = n choose kp^k(1-p)^n-k  quad text for  k = 012 ldots n\n\nSee also: Binomial Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.NegativeBinomialExpert","page":"Expert Functions","title":"LRMoE.NegativeBinomialExpert","text":"NegativeBinomialExpert(n, p)\n\nPMF:\n\nP(X = k) = fracGamma(k+r)k Gamma(r) p^r (1 - p)^k quad textfor  k = 012ldots\n\nSee also: Negative Binomial Distribution (Wolfram) \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.PoissonExpert","page":"Expert Functions","title":"LRMoE.PoissonExpert","text":"PoissonExpert(λ)\n\nPMF:\n\nP(X = k) = fraclambda^kk e^-lambda quad text for  k = 012ldots\n\nSee also: Poisson Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#Continuous-Distributions-(Severity-Modelling)","page":"Expert Functions","title":"Continuous Distributions (Severity Modelling)","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"BurrExpert\nGammaExpert\nInverseGaussianExpert\nLogNormalExpert\nWeibullExpert","category":"page"},{"location":"experts/#LRMoE.BurrExpert","page":"Expert Functions","title":"LRMoE.BurrExpert","text":"BurrExpert(k, c, λ)\n\nPDF:\n\nf(x k c lambda) = frackclambda left( fracxlambda right)^c-1 left( 1+ left( fracxlambda right)^c right)^-k-1\nquad x geq 0\n\nSee also: Burr Distribution (Mathworks, implemented in this package),     Burr Distribution (Wikipedia, with λ = 1)\n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.GammaExpert","page":"Expert Functions","title":"LRMoE.GammaExpert","text":"GammaExpert(k, θ)\n\nPDF:\n\nf(x k theta) = fracx^k-1 e^-xthetaGamma(k) theta^k\nquad x  0\n\nSee also: Gamma Distribution (Wikipedia), shape-scale parameterization \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.InverseGaussianExpert","page":"Expert Functions","title":"LRMoE.InverseGaussianExpert","text":"InverseGaussianExpert(μ, λ)\n\nPDF:\n\nf(x mu lambda) = sqrtfraclambda2pi x^3\nexpleft(frac-lambda(x-mu)^22mu^2xright) \nquad x  0\n\nSee also: Inverse Gaussian Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.LogNormalExpert","page":"Expert Functions","title":"LRMoE.LogNormalExpert","text":"LogNormalExpert(μ, σ)\n\nPDF:\n\nf(x mu sigma) = frac1x sqrt2 pi sigma^2\nexp left( - frac(log(x) - mu)^22 sigma^2 right)\nquad x  0\n\nSee also: Lognormal Distribution (Wikipedia)\n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.WeibullExpert","page":"Expert Functions","title":"LRMoE.WeibullExpert","text":"WeibullExpert(k, θ)\n\nPDF:\n\nf(x k theta) = fracktheta left( fracxtheta right)^k-1 e^-(xtheta)^k\nquad x geq 0\n\nSee also: Weibull Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#Zero-Inflation","page":"Expert Functions","title":"Zero Inflation","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"ZIBinomialExpert\nZINegativeBinomialExpert\nZIPoissonExpert","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"ZIBurrExpert\nZIGammaExpert\nZIInverseGaussianExpert\nZILogNormalExpert\nZIWeibullExpert","category":"page"},{"location":"#LRMoE-Package","page":"Overview","title":"LRMoE Package","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"LRMoE is a package tailor-made for actuarial applications which allows actuarial researchers and practitioners to model and analyze insurance loss frequencies and severities using the Logit-weighted Reduced Mixture-of-Experts (LRMoE) model. The flexibility of LRMoE models is theoretically justified in Fung et al. (2019), and an application of LRMoE for modelling correlated insurance claim frequencies is in Fung et al. (2019).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The package LRMoE offers several new distinctive features which are motivated by various actuarial applications and mostly cannot be achieved using existing packages for mixture models. Key features include:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A wider coverage on frequency and severity distributions and their zero inflation;\nThe flexibility to vary classes of distributions across components;\nParameter estimation under data censoring and truncation;\nA collection of insurance rate making and reserving functions; and\nModel selection and visualization tools.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"While LRMoE was initially developed for actuarial application, this package also allows for customized expert functions for various modelling problems outside of the insurance context. For more details, see here.","category":"page"}]
}
