var documenterSearchIndex = {"docs":
[{"location":"dummytest/#Dummy","page":"Dummy","title":"Dummy","text":"","category":"section"},{"location":"dummytest/","page":"Dummy","title":"Dummy","text":"dummy","category":"page"},{"location":"examples/sim_fit/simulate_fit/#Introduction","page":"Fitting Function","title":"Introduction","text":"","category":"section"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"This document contains the data fitting process for the demo dataset included in the LRMoE.jl package.  This serves as an example of using the main fitting function fit_LRMoE included in the package.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"# Load data\n@load \"X_obs.jld2\" X_obs\n@load \"Y_obs.jld2\" Y_obs","category":"page"},{"location":"examples/sim_fit/simulate_fit/#Fitting-LRMoE","page":"Fitting Function","title":"Fitting LRMoE","text":"","category":"section"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"In this section, we demonstrate how to fit an LRMoE model in the package.  In the current version of LRMoE, the minimal inputs required from the user are:  response, covariates, initialization of logit regression coeffecients and component distributions.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"# Assume a non-informative guess\nα_guess = fill(0.0, 2, 5)\n# Correctly specified component distributions\nmodel_guess = [PoissonExpert(10.0) ZIGammaCountExpert(0.50, 40, 0.80);\n               LogNormalExpert(3.0, 1.0) InverseGaussianExpert(15.0, 15.0)]","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"Now we are ready to call the fitting function. It is optional to print out intermediate updates of parameters. ","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"result_1 = fit_LRMoE(Y_obs, X_obs, α_guess, model_guess)","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"The fitted model can be viewed as follows.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"summary(result_1)","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"Model: LRMoE\nFitting converged after 7 iterations\nDimension of response: 2\nNumber of components: 2\nLoglik: -73153.32112999677\nLoglik (no penalty): -73147.35233984645\nAIC: 146320.7046796929\nBIC: 146414.22545854456\nFitted α:\n[-0.4317549468937167 1.0687536487401863 -0.0501666562042898 0.0951104899516\n9831 1.1966666208577514; 0.0 0.0 0.0 0.0 0.0]\nFitted component distributions:\nAnyExpert{LRMoE.NonNegative,z,d} where d<:(Distribution{Univariate,S} where\n S<:ValueSupport) where z<:ZeroInflation[PoissonExpert{Float64}(6.016755579\n291526) ZIGammaCountExpert{Float64}(0.2061960764035149, 29.956369104025327,\n 0.4888535921075801); LogNormalExpert{Float64}(4.001049211038016, 0.2967339\n201031063) InverseGaussianExpert{Float64}(20.303659308753492, 21.7568654316\n48063)]","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"More specifically, the fitted logit regression coefficients and component distributions are given below. We see that the fitting function can correctly identify the true model within reasonable range.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"result_1.model_fit.α","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"2×5 Array{Float64,2}:\n -0.431755  1.06875  -0.0501667  0.0951105  1.19667\n  0.0       0.0       0.0        0.0        0.0","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"result_1.model_fit.comp_dist","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"2×2 Array{AnyExpert{LRMoE.NonNegative,z,d} where d<:(Distribution{Univariat\ne,S} where S<:ValueSupport) where z<:ZeroInflation,2}:\n PoissonExpert{Float64}(6.01676)              …  ZIGammaCountExpert{Float64\n}(0.206196, 29.9564, 0.488854)\n LogNormalExpert{Float64}(4.00105, 0.296734)     InverseGaussianExpert{Floa\nt64}(20.3037, 21.7569)","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"In practice, it is almost impossible to know the true underlying distribution of data.  Assume the user has conducted some preliminary analysis, and proposes to use the following LRMoE.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"# Assume a non-informative guess\nα_guess = fill(0.0, 2, 5)\n# Incorrectly specified component distributions\nmodel_guess = [ZIPoissonExpert(0.50, 10.0) ZIPoissonExpert(0.50, 20.0);\n               BurrExpert(5.0, 2.0, 30.0) GammaExpert(1.0, 10.0)]","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"We call the fitting function similarly as before.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"result_2 = fit_LRMoE(Y_obs, X_obs, α_guess, model_guess, penalty=true)","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"summary(result_2)","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"Model: LRMoE\nFitting converged after 29 iterations\nDimension of response: 2\nNumber of components: 2\nLoglik: -74522.97988044818\nLoglik (no penalty): -74491.23826492707\nAIC: 149010.47652985415\nBIC: 149111.19121477133\nFitted α:\n[-0.402329688892696 1.0642517348023806 -0.04993352290476096 0.0955025073281\n0937 1.1787815897308458; 0.0 0.0 0.0 0.0 0.0]\nFitted component distributions:\nAnyExpert{LRMoE.NonNegative,z,d} where d<:(Distribution{Univariate,S} where\n S<:ValueSupport) where z<:ZeroInflation[ZIPoissonExpert{Float64}(0.0032705\n87671859084, 6.1027631872596455) ZIPoissonExpert{Float64}(0.206265076006209\n33, 30.584982151431703); BurrExpert{Float64}(1.3092510512796607, 5.23197932\n44529444, 58.7993745083068) GammaExpert{Float64}(1.6243105423038051, 12.398\n187227236122)]","category":"page"},{"location":"examples/sim_fit/simulate_fit/#Fitted-Results","page":"Fitting Function","title":"Fitted Results","text":"","category":"section"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"We can visually examine the fitted results of result_1 and result_2. The following histogram compares dimension 1 of the observed data (green)  with fitted model 1 (blue) and model 2 (red). Since the true model has a slightly heavy tail due to the gamma-count component, model 2 fails to capture this characteristics with only two Poisson components.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"(Image: )","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"The histogram below shows the fitting result for the second dimension (excluding zero inflation). Both models fit the body of data quite well. This is partly because both Burr and Inverse Gaussian distributions are dense (see Fung et al. (2019)).  In other words, they are flexible enough to capture the distribution of response, even under a mis-specified model.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"(Image: )","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"The fitting results can also be demonstrated with the following Q-Q plots. For both dimensions of the response, the mis-specified model 2 gives a slightly worse fit for the tails.","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"(Image: )","category":"page"},{"location":"examples/sim_fit/simulate_fit/","page":"Fitting Function","title":"Fitting Function","text":"(Image: )","category":"page"},{"location":"examples/sim_data/simulate_data/#Introduction","page":"Data Simulation","title":"Introduction","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"This document contains the data generation process for the dataset LRMoEDemoData included  in the LRMoE.jl package. This also serves as an example of using the sim_dataset function  included in the package.","category":"page"},{"location":"examples/sim_data/simulate_data/#Data-Simulation","page":"Data Simulation","title":"Data Simulation","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/#Complete-Data","page":"Data Simulation","title":"Complete Data","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"Suppose there is an auto-insurance company with two lines of business, with a total of 10,000 policies.  The policyholder information includes sex (1 for Male and 0 for Female), driver's age (with range 20 - 80),  car age (with range 0 - 10), and region (1 for urban and 0 for rural).  We assume all covariates are uniformly and independently drawn at random.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"# Random seed for reproducible results\nRandom.seed!(7777)\nsample_size = 10000\n\nintercept = fill(1.0, sample_size)\nsex = rand(Binomial(1, 0.50), sample_size)\naged = rand(Uniform(20, 80), sample_size)\nagec = rand(Uniform(0, 10), sample_size)\nregion = rand(Binomial(1, 0.50), sample_size)\n\nX = DataFrame(intercept = intercept, sex= sex, \n              aged = aged, agec = agec, region = region)","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"The first few rows of X are shown below.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"6×5 DataFrame\n│ Row │ intercept │ sex   │ aged    │ agec      │ region │\n│     │ Float64   │ Int64 │ Float64 │ Float64   │ Int64  │\n├─────┼───────────┼───────┼─────────┼───────────┼────────┤\n│ 1   │ 1.0       │ 1     │ 56.4367 │ 3.3857    │ 1      │\n│ 2   │ 1.0       │ 1     │ 29.7025 │ 2.31892   │ 1      │\n│ 3   │ 1.0       │ 1     │ 33.4796 │ 8.61125   │ 0      │\n│ 4   │ 1.0       │ 0     │ 38.7478 │ 2.88865   │ 1      │\n│ 5   │ 1.0       │ 1     │ 47.348  │ 9.01135   │ 0      │\n│ 6   │ 1.0       │ 1     │ 54.7017 │ 0.0306372 │ 0      │","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"For simplicity, we assume there are two latent risk classes: low (L) and high (H).  The characteristics for the high-risk class are male, young age, old car age and urban region.  This is specified by the following matrix of logit regression coefficients,  where the second row represents the reference class.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"α = [-0.5 1.0 -0.05 0.1 1.25;\n      0.0 0.0   0.0 0.0  0.0]","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"We consider a two-dimensional response: claim frequency from the first business line,  and claim severity from the second business line.  For demonstration purposes and for simplicity, we don't consider the same business line to avoid the complication  where zero frequency necessarily implies zero severity.  The component distributions and their parameters are specified as follows.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"comp_dist = [PoissonExpert(6.0)         ZIGammaCountExpert(0.20, 30, 0.50);\n             LogNormalExpert(4.0, 0.3)  InverseGaussianExpert(20, 20)]","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"The LRMoE.jl package includes a simulator. Given the covariates and parameters defined above,  we can directly simulate a dataset.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"Y_complete = LRMoE.sim_dataset(α, X, comp_dist)","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"The simulated values are plotted as follows.  For each dimension of Y, the histogram is relatively well separated as two components.  This is more or less done on purpose to demonstrate that the fitting procedure can identify the true model  when it is known.  In practice, we are usually less concerned of the underlying data generating distribution,  as long as the LRMoE model provides a reasonable fit of data.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"(Image: )","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"(Image: )","category":"page"},{"location":"examples/sim_data/simulate_data/#Truncation-and-Censoring","page":"Data Simulation","title":"Truncation and Censoring","text":"","category":"section"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"One distinct feature of LRMoE is dealing with data truncation and censoring,  which is common in insurance contexts.  Consequently, instead of one single number for each dimension d, a tuple (tl_d, yl_d, yu_d, tu_d) is required,   where tl_d/tu_d are the lower/upper bounds of truncation, and yl_d/yu_d are the lower/upper bounds of censoring.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"For illustration purposes, we assume the dataset is subject to the following truncation and censoring.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"Index Y_complete[:,1] Y_complete[:,2]\n1-6000 No truncation  or censoring No truncation  or censoring\n6001-8000 No truncation  or censoring Left Truncated at 5\n8001-10000 No truncation  or censoring Right Censored at 100","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"# First block: 1~6000\nX_obs = X[1:6000,:]\n\ntl_1 = fill(0.0, 6000)\nyl_1 = Y_complete[1:6000, 1]\nyu_1 = Y_complete[1:6000, 1]\ntu_1 = fill(Inf, 6000) \n\ntl_2 = fill(0.0, 6000)\nyl_2 = Y_complete[1:6000, 2]\nyu_2 = Y_complete[1:6000, 2]\ntu_2 = fill(Inf, 6000) \n\n# Second block: 6001~8000\nkeep_idx = Y_complete[6001:8000,2] .>=  5\nkeep_length = sum(keep_idx) # 1837 out of 2000\n\nappend!(X_obs, X[6001:8000,:][keep_idx,:])\n\nappend!(tl_1, fill(0.0, keep_length))\nappend!(yl_1, Y_complete[6001:8000, 1][keep_idx])\nappend!(yu_1, Y_complete[6001:8000, 1][keep_idx])\nappend!(tu_1, fill(Inf, keep_length))\n\ny_temp = Y_complete[6001:8000, 2][keep_idx]\nappend!(tl_2, fill(5.0, keep_length))\nappend!(yl_2, Y_complete[6001:8000, 2][keep_idx])\nappend!(yu_2, Y_complete[6001:8000, 2][keep_idx])\nappend!(tu_2, fill(Inf, keep_length))\n\n# Third block: 8001~10000\nappend!(X_obs, X[8001:10000,:])\n\nappend!(tl_1, fill(0.0, 2000))\nappend!(yl_1, Y_complete[8001:10000, 1])\nappend!(yu_1, Y_complete[8001:10000, 1])\nappend!(tu_1, fill(Inf, 2000))\n\ny_temp = Y_complete[8001:10000, 2]\ncensor_idx = y_temp .>= 100.0 # 21 out of 2000\nyl_temp = copy(y_temp)\nyl_temp[censor_idx] .= 100\nyu_temp = copy(y_temp)\nyu_temp[censor_idx] .= Inf\nappend!(tl_2, fill(0.0, 2000))\nappend!(yl_2, yl_temp)\nappend!(yu_2, yu_temp)\nappend!(tu_2, fill(Inf, 2000))\n\n# Put things together\nY_obs = DataFrame(tl_1 = tl_1, yl_1 = yl_1, yu_1 = yu_1, tu_1 = tu_1,\n                  tl_2 = tl_2, yl_2 = yl_2, yu_2 = yu_2, tu_2 = tu_2)","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"As a result of truncating Y_complete[:,2], 163 rows are discarded,  leaving 9837 observations available for model fitting. Sample data points are show below.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"3×4 DataFrame\n│ Row │ tl_1    │ yl_1    │ yu_1    │ tu_1    │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┤\n│ 1   │ 0.0     │ 6.0     │ 6.0     │ Inf     │\n│ 2   │ 0.0     │ 8.0     │ 8.0     │ Inf     │\n│ 3   │ 0.0     │ 7.0     │ 7.0     │ Inf     │","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"3×4 DataFrame\n│ Row │ tl_2    │ yl_2    │ yu_2    │ tu_2    │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┤\n│ 1   │ 0.0     │ 89.0332 │ 89.0332 │ Inf     │\n│ 2   │ 5.0     │ 37.4133 │ 37.4133 │ Inf     │\n│ 3   │ 0.0     │ 100.0   │ Inf     │ Inf     │","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"We will export both the complete and incomplete datasets to the LRMoE.jl package.","category":"page"},{"location":"examples/sim_data/simulate_data/","page":"Data Simulation","title":"Data Simulation","text":"@save \"X_complete.jld2\" X\n@save \"Y_complete.jld2\" Y_complete\n@save \"X_obs.jld2\" X_obs\n@save \"Y_obs.jld2\" Y_obs","category":"page"},{"location":"framework/#Modelling-Framework","page":"Modelling Framework","title":"Modelling Framework","text":"","category":"section"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"The LRMoE model is formulated as follows. Let (mathbfx_i mathbfy_i) i = 1 2 dots n denote a set of observations, where mathbfx_i denotes the covariates and mathbfy_i the response(s).","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Given mathbfx_i, the i-th observation is classified into one of g latent classes by the so-called logit gating function. The probability of belonging to the j-th latent class is given by","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"pi_j(mathbfx_i mathbfalpha) = fracexp (mathbfalpha_j^T mathbfx_i)sum_j=1^g exp (mathbfalpha_j^T mathbfx_i) quad j = 1 2 dots g-1","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"For model identifiability reasons, we assume mathbfalpha_g = mathbf0 which corresponds to the reference class.","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Conditional on the latent class j, the distribution of the response mathbfy_i is given by an expert function with density","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"f_j(mathbfy_i mathbfpsi_j) = prod_d=1^D f_jd(mathbfy_id mathbfpsi_jd)","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"where we assume conditional independence of dimensions 1 2 dots D of mathbfy_i, if it is a vector of responses.","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"The likelihood function is therefore","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"L(mathbfalpha mathbfpsi mathbfx mathbfy) = prod_i=1^n left sum_j=1^g pi_j(mathbfx_i mathbfalpha) f_j(mathbfy_i mathbfpsi_j) right","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Notice that the parameters mathbfpsi_j do not involve regression on the covariates mathbfx_i, hence the model is termed as reduced. For an introduction to the general mixture-of-experts models, see e.g. here.","category":"page"},{"location":"framework/","page":"Modelling Framework","title":"Modelling Framework","text":"Fung et al. (2019) have shown that such simplification of model structure will not reduce its flexibility, and will significantly reduce the computation efforts in model inference. The parameters to estimate are the regression coefficients mathbfalpha_j and parameters of the expert functions mathbfpsi_j, which is implemented by the standard Expectation-Conditional-Maximization algorithm (details omitted).","category":"page"},{"location":"predictive/#Predictive-Functions","page":"Predictive Functions","title":"Predictive Functions","text":"","category":"section"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"After fitting an LRMoE model, the following predictive functions provide further insights into the dataset. These functions start with predict_ followed by a quantity of interest (e.g. mean_) listed below.","category":"page"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"class: latent class probabilities and the most likely latent class;\nmean: mean of response;\nvar: variance of response;\nlimit: limited expected value (LEV) of response, that is, Emin(Y d);\nexcess: expected excess value of response, that is, Emax(Y-d 0); and\nVaRCTE: quantile (or Value-at-Risk/VaR) and conditional tail expectation (CTE, or tail-VaR/TVaR) of response.","category":"page"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"These quantities can be calculated based on either the prior and posterior latent class probabilities, as indicated by the suffix of these functions.","category":"page"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"prior: the latent class probabilities are based on the covariates X and logit regression coefficients α.\nposterior: the latent class probabilities are based on the covariates X, logit regression coefficients α and observed values Y.","category":"page"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"The differences of these probabilities can be found in Fung et al. (2019).","category":"page"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"The following contains a detailed description of all predictive functions included in the package. Throughout this page, Y is a matrix of response, X a matrix of covariates, α a matrix of logit regression coefficients and model a matrix of expert functions.","category":"page"},{"location":"predictive/","page":"Predictive Functions","title":"Predictive Functions","text":"predict_class_prior\npredict_class_posterior\npredict_mean_prior\npredict_mean_posterior\npredict_var_prior\npredict_var_posterior\npredict_limit_prior\npredict_limit_posterior\npredict_excess_prior\npredict_excess_posterior\npredict_VaRCTE_prior\npredict_VaRCTE_posterior","category":"page"},{"location":"predictive/#LRMoE.predict_class_prior","page":"Predictive Functions","title":"LRMoE.predict_class_prior","text":"predict_class_prior(X, α)\n\nPredicts the latent class probabilities,  given covariates X  and logit regression coefficients α.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\n\nReturn Values\n\nprob: A matrix of latent class probabilities.\nmax_prob_idx: A matrix of the most likely latent class for each observation.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_class_posterior","page":"Predictive Functions","title":"LRMoE.predict_class_posterior","text":"predict_class_posterior(Y, X, α, model)\n\nPredicts the latent class probabilities,  given observations Y, covariates X,  logit regression coefficients α and a specified model of expert functions. \n\nArguments\n\nY: A matrix of responses.\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\n\nReturn Values\n\nprob: A matrix of latent class probabilities.\nmax_prob_idx: A matrix of the most likely latent class for each observation.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_mean_prior","page":"Predictive Functions","title":"LRMoE.predict_mean_prior","text":"predict_mean_prior(X, α, model)\n\nPredicts the mean values of response,  given covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\n\nReturn Values\n\nA matrix of predicted mean values of response, based on prior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_mean_posterior","page":"Predictive Functions","title":"LRMoE.predict_mean_posterior","text":"predict_mean_posterior(Y, X, α, model)\n\nPredicts the mean values of response, given observations Y, covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nY: A matrix of responses.\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\n\nReturn Values\n\nA matrix of predicted mean values of response, based on posterior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_var_prior","page":"Predictive Functions","title":"LRMoE.predict_var_prior","text":"predict_var_prior(X, α, model)\n\nPredicts the variance of response,  given covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\n\nReturn Values\n\nA matrix of predicted variance of response, based on prior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_var_posterior","page":"Predictive Functions","title":"LRMoE.predict_var_posterior","text":"predict_var_posterior(Y, X, α, model)\n\nPredicts the variance of response,  given observations Y, covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nY: A matrix of responses.\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\n\nReturn Values\n\nA matrix of predicted variance of response, based on posterior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_limit_prior","page":"Predictive Functions","title":"LRMoE.predict_limit_prior","text":"predict_limit_prior(X, α, model, limit)\n\nPredicts the limit expected value (LEV) of response,  given covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\nlimit: A vector specifying the cutoff point.\n\nReturn Values\n\nA matrix of predicted limit expected value of response, based on prior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_limit_posterior","page":"Predictive Functions","title":"LRMoE.predict_limit_posterior","text":"predict_limit_posterior(Y, X, α, model, limit)\n\nPredicts the limit expected value (LEV) of response,  given observations Y, covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nY: A matrix of responses.\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\nlimit: A vector specifying the cutoff point.\n\nReturn Values\n\nA matrix of predicted limit expected value of response, based on posterior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_excess_prior","page":"Predictive Functions","title":"LRMoE.predict_excess_prior","text":"predict_excess_prior(X, α, model, limit)\n\nPredicts the excess expectation of response,  given covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\nlimit: A vector specifying the cutoff point.\n\nReturn Values\n\nA matrix of predicted excess expectation of response, based on prior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_excess_posterior","page":"Predictive Functions","title":"LRMoE.predict_excess_posterior","text":"predict_excess_posterior(Y, X, α, model, limit)\n\nPredicts the excess expectation of response,  given observations Y, covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nY: A matrix of responses.\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\nlimit: A vector specifying the cutoff point.\n\nReturn Values\n\nA matrix of predicted excess expectation of response, based on posterior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_VaRCTE_prior","page":"Predictive Functions","title":"LRMoE.predict_VaRCTE_prior","text":"predict_VaRCTE_prior(X, α, model, p)\n\nPredicts the p-th value-at-risk (VaR) and conditional tail expectation (CTE) of response,  given covariates X,  logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\np: A vector of probabilities.\n\nReturn Values\n\nVaR: A matrix of predicted VaR of response, based on prior probabilities.\nCTE: A matrix of predicted CTE of response, based on prior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"predictive/#LRMoE.predict_VaRCTE_posterior","page":"Predictive Functions","title":"LRMoE.predict_VaRCTE_posterior","text":"predict_VaRCTE_posterior(Y, X, α, model, p)\n\nPredicts the p-th value-at-risk (VaR) and conditional tail expectation (CTE) of response,  given observations Y, covariates X, logit regression coefficients α and a specified model of expert functions.\n\nArguments\n\nX: A matrix of covariates.\nα: A matrix of logit regression coefficients.\nmodel: A matrix specifying the expert functions.\np: A vector of probabilities.\n\nReturn Values\n\nVaR: A matrix of predicted VaR of response, based on posterior probabilities.\nCTE: A matrix of predicted CTE of response, based on posterior probabilities.\n\n\n\n\n\n","category":"function"},{"location":"experts/#Expert-Functions","page":"Expert Functions","title":"Expert Functions","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"The LRMoE package supports a collection of distributions commonly used for modelling insurance claim frequency and severity.","category":"page"},{"location":"experts/#Type-Hierarchy","page":"Expert Functions","title":"Type Hierarchy","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Expert functions are implemented as subtypes of the AnyExpert type in this package. A good number of expert functions are simply wrappers around the UnivariateDistribution type in Distributions.jl (details here), and functions such as pdf and cdf are also directly using those in Distributions.jl.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Specific to actuarial application, a collection of commonly used distributions are also included in this package, e.g. Burr, GammaCount, etc. See below for details.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Expert functions can be defined either on the real line, or only on nonnegative values (as is usually the case for actuarial loss modelling).","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"# Abstract type: support of expert function\nabstract type ExpertSupport end\nstruct RealValued <: ExpertSupport end\nstruct NonNegative <: ExpertSupport end","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Considering zero inflation is prominant in many actuarial applications, expert functions can be either zero-inflated or not, provided that they are supported only on nonnegative values.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"# Abstract type: whether the expert is zero-inflated\nabstract type ZeroInflation end\nstruct ZI <: ZeroInflation end\nstruct NonZI <: ZeroInflation end","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Each expert function is a univariate distribution (see here for UnivariateDistribution in Distributions.jl), with appropriate indication of support and zero inflation. ","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"# Abstract type: AnyExpert\nabstract type AnyExpert{s<:ExpertSupport, z<:ZeroInflation, d<:UnivariateDistribution} end\n# Discrete or Continuous\nconst DiscreteExpert{s<:ExpertSupport, z<:ZeroInflation} = \n                AnyExpert{s, z, DiscreteUnivariateDistribution}\nconst ContinuousExpert{s<:ExpertSupport, z<:ZeroInflation} = \n                AnyExpert{s, z, ContinuousUnivariateDistribution}\n# Real-valued expert distributions\nconst RealDiscreteExpert = DiscreteExpert{RealValued, NonZI}\nconst RealContinuousExpert = ContinuousExpert{RealValued, NonZI}\n# Nonnegative-valued expert distributions\nconst NonNegDiscreteExpert{z<:ZeroInflation} = DiscreteExpert{NonNegative, z}\nconst NonNegContinuousExpert{z<:ZeroInflation} = ContinuousExpert{NonNegative, z}\n# Zero-inflated\nconst ZIDiscreteExpert = NonNegDiscreteExpert{ZI}\nconst ZIContinuousExpert = NonNegContinuousExpert{ZI}\n# Non zero-inflated\nconst NonZIDiscreteExpert = NonNegDiscreteExpert{NonZI}\nconst NonZIContinuousExpert = NonNegContinuousExpert{NonZI}","category":"page"},{"location":"experts/#Discrete-Distributions-(Frequency-Modelling)","page":"Expert Functions","title":"Discrete Distributions (Frequency Modelling)","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"BinomialExpert\nNegativeBinomialExpert\nPoissonExpert","category":"page"},{"location":"experts/#LRMoE.BinomialExpert","page":"Expert Functions","title":"LRMoE.BinomialExpert","text":"BinomialExpert(n, p)\n\nPMF:\n\nP(X = k) = n choose kp^k(1-p)^n-k  quad text for  k = 012 ldots n\n\nSee also: Binomial Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.NegativeBinomialExpert","page":"Expert Functions","title":"LRMoE.NegativeBinomialExpert","text":"NegativeBinomialExpert(n, p)\n\nPMF:\n\nP(X = k) = fracGamma(k+r)k Gamma(r) p^r (1 - p)^k quad textfor  k = 012ldots\n\nSee also: Negative Binomial Distribution (Wolfram) \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.PoissonExpert","page":"Expert Functions","title":"LRMoE.PoissonExpert","text":"PoissonExpert(λ)\n\nPMF:\n\nP(X = k) = fraclambda^kk e^-lambda quad text for  k = 012ldots\n\nSee also: Poisson Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#Continuous-Distributions-(Severity-Modelling)","page":"Expert Functions","title":"Continuous Distributions (Severity Modelling)","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"BurrExpert\nGammaExpert\nInverseGaussianExpert\nLogNormalExpert\nWeibullExpert","category":"page"},{"location":"experts/#LRMoE.BurrExpert","page":"Expert Functions","title":"LRMoE.BurrExpert","text":"BurrExpert(k, c, λ)\n\nPDF:\n\nf(x k c lambda) = frackclambda left( fracxlambda right)^c-1 left( 1+ left( fracxlambda right)^c right)^-k-1\nquad x geq 0\n\nSee also: Burr Distribution (Mathworks, implemented in this package),     Burr Distribution (Wikipedia, with λ = 1)\n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.GammaExpert","page":"Expert Functions","title":"LRMoE.GammaExpert","text":"GammaExpert(k, θ)\n\nPDF:\n\nf(x k theta) = fracx^k-1 e^-xthetaGamma(k) theta^k\nquad x  0\n\nSee also: Gamma Distribution (Wikipedia), shape-scale parameterization \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.InverseGaussianExpert","page":"Expert Functions","title":"LRMoE.InverseGaussianExpert","text":"InverseGaussianExpert(μ, λ)\n\nPDF:\n\nf(x mu lambda) = sqrtfraclambda2pi x^3\nexpleft(frac-lambda(x-mu)^22mu^2xright) \nquad x  0\n\nSee also: Inverse Gaussian Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.LogNormalExpert","page":"Expert Functions","title":"LRMoE.LogNormalExpert","text":"LogNormalExpert(μ, σ)\n\nPDF:\n\nf(x mu sigma) = frac1x sqrt2 pi sigma^2\nexp left( - frac(log(x) - mu)^22 sigma^2 right)\nquad x  0\n\nSee also: Lognormal Distribution (Wikipedia)\n\n\n\n\n\n","category":"type"},{"location":"experts/#LRMoE.WeibullExpert","page":"Expert Functions","title":"LRMoE.WeibullExpert","text":"WeibullExpert(k, θ)\n\nPDF:\n\nf(x k theta) = fracktheta left( fracxtheta right)^k-1 e^-(xtheta)^k\nquad x geq 0\n\nSee also: Weibull Distribution (Wikipedia) \n\n\n\n\n\n","category":"type"},{"location":"experts/#Zero-Inflation","page":"Expert Functions","title":"Zero Inflation","text":"","category":"section"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"Zero inflation is supported for all discrete and continuous experts. They can be constructed by adding ZI in front of an expert function, with an additional parameter p (or p0 if the expert already uses p, e.g. binomial) for modelling a probability mass at zero. Zero-inflated experts are used in the same way as their non-zero-inflated counterpart. A complete list of  zero-inflated expert functions is given below.","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"ZIBinomialExpert(p0, n, p)\nZINegativeBinomialExpert(p0, n, p)\nZIPoissonExpert(p, λ)","category":"page"},{"location":"experts/","page":"Expert Functions","title":"Expert Functions","text":"ZIBurrExpert(p, k, c, λ)\nZIGammaExpert(p, k, θ)\nZIInverseGaussianExpert(p, μ, λ)\nZILogNormalExpert(p, μ, σ)\nZIWeibullExpert(p, k, θ)","category":"page"},{"location":"#LRMoE-Package","page":"Overview","title":"LRMoE Package","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"LRMoE is a package tailor-made for actuarial applications which allows actuarial researchers and practitioners to model and analyze insurance loss frequencies and severities using the Logit-weighted Reduced Mixture-of-Experts (LRMoE) model. The flexibility of LRMoE models is theoretically justified in Fung et al. (2019), and an application of LRMoE for modelling correlated insurance claim frequencies is in Fung et al. (2019).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The package LRMoE offers several new distinctive features which are motivated by various actuarial applications and mostly cannot be achieved using existing packages for mixture models. Key features include:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A wider coverage on frequency and severity distributions and their zero inflation;\nThe flexibility to vary classes of distributions across components;\nParameter estimation under data censoring and truncation;\nA collection of insurance rate making and reserving functions; and\nModel selection and visualization tools.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"While LRMoE was initially developed for actuarial application, this package also allows for customized expert functions for various modelling problems outside of the insurance context. For more details, see here.","category":"page"}]
}
