<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding Customized Expert Functions · LRMoE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LRMoE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../framework/">Modelling Framework</a></li><li><a class="tocitem" href="../experts/">Expert Functions</a></li><li><a class="tocitem" href="../predictive/">Predictive Functions</a></li><li><span class="tocitem">Examples &amp; Tutorials</span><ul><li><a class="tocitem" href="../examples/sim_data/simulate_data/">Data Simulation</a></li><li><a class="tocitem" href="../examples/sim_fit/simulate_fit/">Fitting Function</a></li><li class="is-active"><a class="tocitem" href>Adding Customized Expert Functions</a><ul class="internal"><li><a class="tocitem" href="#Type-Hierarchy"><span>Type Hierarchy</span></a></li><li><a class="tocitem" href="#Example:-Gamma-Expert"><span>Example: Gamma Expert</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples &amp; Tutorials</a></li><li class="is-active"><a href>Adding Customized Expert Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adding Customized Expert Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sparktseung/LRMoE.jl/blob/master/docs/src/customize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="customize_experts"><a class="docs-heading-anchor" href="#customize_experts">Adding Customized Expert Functions</a><a id="customize_experts-1"></a><a class="docs-heading-anchor-permalink" href="#customize_experts" title="Permalink"></a></h1><p>In addition to the expert functions included in the package, users can also write their own expert functions specific to a particular modelling problem (not confined within actuarial contexts).</p><h2 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h2><p>Expert functions are implemented as subtypes of the <code>AnyExpert</code> type in this package. A good number of expert functions are simply wrappers around the <code>UnivariateDistribution</code> type in <code>Distributions.jl</code> (details <a href="https://juliastats.org/Distributions.jl/stable/types/">here</a>), and functions such as <code>pdf</code> and <code>cdf</code> are also directly using those in <code>Distributions.jl</code>.</p><p>Expert functions can be defined either on the real line, or only on nonnegative values (as is usually the case for actuarial loss modelling).</p><pre><code class="language-julia"># Abstract type: support of expert function
abstract type ExpertSupport end
struct RealValued &lt;: ExpertSupport end
struct NonNegative &lt;: ExpertSupport end</code></pre><p>Considering zero inflation is prominant in many actuarial applications, expert functions can be either zero-inflated or not, provided that they are supported only on nonnegative values.</p><pre><code class="language-julia"># Abstract type: whether the expert is zero-inflated
abstract type ZeroInflation end
struct ZI &lt;: ZeroInflation end
struct NonZI &lt;: ZeroInflation end</code></pre><p>Each expert function is a univariate distribution (see <a href="https://juliastats.org/Distributions.jl/stable/univariate/">here</a> for <code>UnivariateDistribution</code> in <code>Distributions.jl</code>), with appropriate indication of support and zero inflation. </p><pre><code class="language-julia"># Abstract type: AnyExpert
abstract type AnyExpert{s&lt;:ExpertSupport, z&lt;:ZeroInflation, d&lt;:UnivariateDistribution} end
# Discrete or Continuous
const DiscreteExpert{s&lt;:ExpertSupport, z&lt;:ZeroInflation} = 
                AnyExpert{s, z, DiscreteUnivariateDistribution}
const ContinuousExpert{s&lt;:ExpertSupport, z&lt;:ZeroInflation} = 
                AnyExpert{s, z, ContinuousUnivariateDistribution}
# Real-valued expert distributions
const RealDiscreteExpert = DiscreteExpert{RealValued, NonZI}
const RealContinuousExpert = ContinuousExpert{RealValued, NonZI}
# Nonnegative-valued expert distributions
const NonNegDiscreteExpert{z&lt;:ZeroInflation} = DiscreteExpert{NonNegative, z}
const NonNegContinuousExpert{z&lt;:ZeroInflation} = ContinuousExpert{NonNegative, z}
# Zero-inflated
const ZIDiscreteExpert = NonNegDiscreteExpert{ZI}
const ZIContinuousExpert = NonNegContinuousExpert{ZI}
# Non zero-inflated
const NonZIDiscreteExpert = NonNegDiscreteExpert{NonZI}
const NonZIContinuousExpert = NonNegContinuousExpert{NonZI}</code></pre><h2 id="Example:-Gamma-Expert"><a class="docs-heading-anchor" href="#Example:-Gamma-Expert">Example: Gamma Expert</a><a id="Example:-Gamma-Expert-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Gamma-Expert" title="Permalink"></a></h2><p>As an example, we will use the Gamma expert to demonstrate how to write a customized expert function for any continuous distribution. For discrete distributions, the Poisson distribution is a good example, but we will omit the details here. In this illustrative example, we will go through the source code of Gamma Expert (available <a href="https://github.com/sparktseung/LRMoE.jl/blob/main/src/experts/continuous/gamma.jl">here</a>) to see what is needed to add a customized expert function.</p><p>Before starting, we create a new source code file <code>gamma.jl</code> for Gamma expert, and  put it in the corresponding folder, i.e. <code>src/experts/continuous</code>.</p><h3 id="Defining-a-struct"><a class="docs-heading-anchor" href="#Defining-a-struct">Defining a struct</a><a id="Defining-a-struct-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-struct" title="Permalink"></a></h3><p>The first step is to define the Gamma expert function and some basic and common functions shared by all experts. This corresponds to the first block of the source code. The details are quite similar to  adding a customized distribution to <code>Distributions.jl</code>, including defining the new <code>GammaExpert</code> as a sub-type of <code>NonZIContinuousExpert</code>,  some constructors and conversions of parameters.</p><pre><code class="language-julia">struct GammaExpert{T&lt;:Real} &lt;: NonZIContinuousExpert
    k::T
    θ::T
    GammaExpert{T}(k::T, θ::T) where {T&lt;:Real} = new{T}(k, θ)
end

function GammaExpert(k::T, θ::T; check_args=true) where {T &lt;: Real}
    check_args &amp;&amp; @check_args(GammaExpert, k &gt;= zero(k) &amp;&amp; θ &gt; zero(θ))
    return GammaExpert{T}(k, θ)
end

## Outer constructors
GammaExpert(k::Real, θ::Real) = GammaExpert(promote(k, θ)...)
GammaExpert(k::Integer, θ::Integer) = GammaExpert(float(k), float(θ))
GammaExpert() = GammaExpert(1.0, 1.0)

## Conversion
function convert(::Type{GammaExpert{T}}, k::S, θ::S) where {T &lt;: Real, S &lt;: Real}
    GammaExpert(T(k), T(θ))
end
function convert(::Type{GammaExpert{T}}, d::GammaExpert{S}) where {T &lt;: Real, S &lt;: Real}
    GammaExpert(T(d.k), T(d.θ), check_args=false)
end
copy(d::GammaExpert) = GammaExpert(d.k, d.θ, check_args=false)</code></pre><h3 id="Exporting-the-expert-function"><a class="docs-heading-anchor" href="#Exporting-the-expert-function">Exporting the expert function</a><a id="Exporting-the-expert-function-1"></a><a class="docs-heading-anchor-permalink" href="#Exporting-the-expert-function" title="Permalink"></a></h3><p>This step should technically be at the very end, but we introduce it here to facilitate testing during development. In order for the expert function to be accessible to the user, it should be exported by modifying the files <code>src/experts/expert.jl</code> and <code>src/LRMoE.jl</code>: In the former, <code>gamma</code> is added to <code>contintous_experts</code> so that the source file <code>src/experts/continuous/gamma.jl</code> is included; In the latter, <code>GammaExpert</code> is exported so that the gamma expert function is accessible outside of the package.</p><h3 id="Basic-and-additional-functions"><a class="docs-heading-anchor" href="#Basic-and-additional-functions">Basic and additional functions</a><a id="Basic-and-additional-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-and-additional-functions" title="Permalink"></a></h3><p>For all expert functions, there are a number of basic functions absolutely needed for using the package. In addition, some functions may be omitted (e.g. calculating limited expected value) if they are not relevant to the modeling problem at hand.</p><p><strong>Basic probability functions</strong>: <code>pdf</code>, <code>logpdf</code>, <code>cdf</code> and <code>logcdf</code>. These are used for calculating the loglikelihood of the model. Notice that for <code>logpdf</code> etc., we have directly used the corresponding functions in <code>Distributions.jl</code> since the Gamma distribution is already implemented there. If this is not the case, the user can also add a new distribution type following the guide in <code>Distributions.jl</code>, and add the source code to the folder <code>src/experts/add_dist</code>.</p><pre><code class="language-julia">## Loglikelihood of Expert
logpdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? -Inf : Distributions.logpdf.(Distributions.Gamma(d.k, d.θ), x...)
pdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? 0.0 : Distributions.pdf.(Distributions.Gamma(d.k, d.θ), x...)
logcdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? -Inf : Distributions.logcdf.(Distributions.Gamma(d.k, d.θ), x...)
cdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? 0.0 : Distributions.cdf.(Distributions.Gamma(d.k, d.θ), x...)</code></pre><p><strong>Parameters and initialization</strong>: The following functions are necessary for calling the functions to initialize parameters (e.g. <code>cmm_init_params</code>).</p><p>In the following <code>params_init</code> function, we assume a vector of observations <code>y</code>, and match the first two moments to solve for the parameters of a gamma distribution. Notice that the function should return an expert function, not the parameter values. Also, an empty expert should also be added to the corresponding list in <code>src/paramsinit.jl</code>. In this case, <code>GammaExpert()</code> is added to <code>_default_expert_continuous</code>.</p><p>The function <code>ks_distance</code> is used to select an initialization of expert which has the lowest test statistics for the Kolmogorov-Smirnov test, in other words, the K-S distance is minimized. The <code>ks_distance</code> simply calculates the test statistics given a vector of observations <code>y</code> and an expert function <code>GammaExpert</code> (i.e. to see if the observations <code>y</code> come from a Gamma distribution).</p><pre><code class="language-julia">## Parameters
params(d::GammaExpert) = (d.k, d.θ)
function params_init(y, d::GammaExpert)
    pos_idx = (y .&gt; 0.0)
    μ, σ2 = mean(y[pos_idx]), var(y[pos_idx])
    θ_init = σ2/μ
    k_init = μ/θ_init
    if isnan(θ_init) || isnan(k_init)
        return GammaExpert()
    else
        return GammaExpert(k_init, θ_init)
    end
end

## KS stats for parameter initialization
function ks_distance(y, d::GammaExpert)
    p_zero = sum(y .== 0.0) / sum(y .&gt;= 0.0)
    return max(abs(p_zero-0.0), (1-0.0)*HypothesisTests.ksstats(y[y .&gt; 0.0], Distributions.Gamma(d.k, d.θ))[2])
end</code></pre><p><strong>Simulation</strong>: A simulator is also needed, which simulates a vector of length <code>sample_size</code> from the expert function.</p><pre><code class="language-julia">## Simululation
sim_expert(d::GammaExpert, sample_size) = Distributions.rand(Distributions.Gamma(d.k, d.θ), sample_size)</code></pre><p><strong>Penalty on parameters</strong>: This is also required. When fitting mixture models, the EM algorithm may converge to a spurious model with extremely large or small parameter values, which is undesirable for a number of reasons (e.g. giving infinite likelihood, or straight up a NaN error). Hence, a penalty is imposed for these extreme cases. In implementation, we essentially assume the parameters have a prior distribution described by some hyperparameters. Consequently, the EM step is essentially maximizing a posterior loglikelihood.</p><p>As a rule of thumb, we assume a Gamma prior for positive parameters and a Normal prior for real parameters. For example, the penalty terms for Gamma experts are coded as follows. </p><pre><code class="language-julia">## penalty
penalty_init(d::GammaExpert) = [2.0 10.0 2.0 10.0]
no_penalty_init(d::GammaExpert) = [1.0 Inf 1.0 Inf]
penalize(d::GammaExpert, p) = (p[1]-1)*log(d.k) - d.k/p[2] + (p[3]-1)*log(d.θ) - d.θ/p[4]</code></pre><p>In the function <code>penalize</code>, the hyperparameters are given as a vector <code>p</code>. We assume the shape parameter <code>k</code> of the Gamma expert follows a Gamma prior distribution with shape <code>p[1]</code> and scale <code>p[2]</code>. Analogously, the scale parameter <code>θ</code> of the Gamma expert follows a Gamma prior distribution with shape <code>p[1]</code> and scale <code>p[2]</code> of the Gamma expert follows a Gamma prior distribution with shape <code>p[3]</code> and scale <code>p[3]</code>. The <code>penalize</code> function calculates the prior logpdf of the parameters, excluding the constant terms since they are irrelevant to the EM algorithm.</p><p>The functions <code>penalty_init</code> initializes some default hyperparameters, if they are not given by the user. Similarly, <code>no_penalty_init</code> speficies hyperparameters which poses no penalty, as plugging ion <code>p = [1.0 Inf 1.0 Inf]</code> into the <code>penalize</code> function yields zero. Still, it is recommended to always use some penalty in application to avoid the issue of spurious models mentioned above.</p><h3 id="Maximizing-loglikelihood:-exact-observation"><a class="docs-heading-anchor" href="#Maximizing-loglikelihood:-exact-observation">Maximizing loglikelihood: exact observation</a><a id="Maximizing-loglikelihood:-exact-observation-1"></a><a class="docs-heading-anchor-permalink" href="#Maximizing-loglikelihood:-exact-observation" title="Permalink"></a></h3><p>The next step is to derive the loglikelihood of a Gamma distribution, which is given in Section 3.2 of <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3740061">Fung et al. (2019)</a>. Notice that the cited paper considers the issue of data truncation and censoring, but as a first step, we will just assume all data are observed exactly. Data truncation and censoring are dealt with afterwards.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/sim_fit/simulate_fit/">« Fitting Function</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 21 January 2021 20:19">Thursday 21 January 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
