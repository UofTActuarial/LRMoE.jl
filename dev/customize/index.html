<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding Customized Expert Functions · LRMoE.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LRMoE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../framework/">Modelling Framework</a></li><li><a class="tocitem" href="../experts/">Expert Functions</a></li><li><a class="tocitem" href="../init/">Model Initialization</a></li><li><a class="tocitem" href="../fit/">Fitting Function</a></li><li><a class="tocitem" href="../predictive/">Predictive Functions</a></li><li><span class="tocitem">Examples &amp; Tutorials</span><ul><li><a class="tocitem" href="../examples/sim_data/simulate_data/">Data Simulation</a></li><li><a class="tocitem" href="../data_format/">Data Formatting</a></li><li><a class="tocitem" href="../examples/sim_fit/simulate_fit/">Fitting Function</a></li><li class="is-active"><a class="tocitem" href>Adding Customized Expert Functions</a><ul class="internal"><li><a class="tocitem" href="#Type-Hierarchy"><span>Type Hierarchy</span></a></li><li><a class="tocitem" href="#Example:-Gamma-Expert"><span>Example: Gamma Expert</span></a></li><li><a class="tocitem" href="#Notes-and-tips"><span>Notes and tips</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples &amp; Tutorials</a></li><li class="is-active"><a href>Adding Customized Expert Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adding Customized Expert Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UofTActuarial/LRMoE.jl/blob/main/docs/src/customize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="customize_experts"><a class="docs-heading-anchor" href="#customize_experts">Adding Customized Expert Functions</a><a id="customize_experts-1"></a><a class="docs-heading-anchor-permalink" href="#customize_experts" title="Permalink"></a></h1><p>In addition to the expert functions included in the package, users can also write their own expert functions specific to a particular modelling problem (not confined within actuarial contexts).</p><h2 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h2><p>Expert functions are implemented as subtypes of the <code>AnyExpert</code> type in this package. A good number of expert functions are simply wrappers around the <code>UnivariateDistribution</code> type in <code>Distributions.jl</code> (details <a href="https://juliastats.org/Distributions.jl/stable/types/">here</a>), and functions such as <code>pdf</code> and <code>cdf</code> are also directly using those in <code>Distributions.jl</code>.</p><p>Expert functions can be defined either on the real line, or only on nonnegative values (as is usually the case for actuarial loss modelling).</p><pre><code class="language-julia hljs"># Abstract type: support of expert function
abstract type ExpertSupport end
struct RealValued &lt;: ExpertSupport end
struct NonNegative &lt;: ExpertSupport end</code></pre><p>Considering zero inflation is prominant in many actuarial applications, expert functions can be either zero-inflated or not, provided that they are supported only on nonnegative values.</p><pre><code class="language-julia hljs"># Abstract type: whether the expert is zero-inflated
abstract type ZeroInflation end
struct ZI &lt;: ZeroInflation end
struct NonZI &lt;: ZeroInflation end</code></pre><p>Each expert function is a univariate distribution (see <a href="https://juliastats.org/Distributions.jl/stable/univariate/">here</a> for <code>UnivariateDistribution</code> in <code>Distributions.jl</code>), with appropriate indication of support and zero inflation. </p><pre><code class="language-julia hljs"># Abstract type: AnyExpert
abstract type AnyExpert{s&lt;:ExpertSupport, z&lt;:ZeroInflation, d&lt;:UnivariateDistribution} end
# Discrete or Continuous
const DiscreteExpert{s&lt;:ExpertSupport, z&lt;:ZeroInflation} = 
                AnyExpert{s, z, DiscreteUnivariateDistribution}
const ContinuousExpert{s&lt;:ExpertSupport, z&lt;:ZeroInflation} = 
                AnyExpert{s, z, ContinuousUnivariateDistribution}
# Real-valued expert distributions
const RealDiscreteExpert = DiscreteExpert{RealValued, NonZI}
const RealContinuousExpert = ContinuousExpert{RealValued, NonZI}
# Nonnegative-valued expert distributions
const NonNegDiscreteExpert{z&lt;:ZeroInflation} = DiscreteExpert{NonNegative, z}
const NonNegContinuousExpert{z&lt;:ZeroInflation} = ContinuousExpert{NonNegative, z}
# Zero-inflated
const ZIDiscreteExpert = NonNegDiscreteExpert{ZI}
const ZIContinuousExpert = NonNegContinuousExpert{ZI}
# Non zero-inflated
const NonZIDiscreteExpert = NonNegDiscreteExpert{NonZI}
const NonZIContinuousExpert = NonNegContinuousExpert{NonZI}</code></pre><h2 id="Example:-Gamma-Expert"><a class="docs-heading-anchor" href="#Example:-Gamma-Expert">Example: Gamma Expert</a><a id="Example:-Gamma-Expert-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Gamma-Expert" title="Permalink"></a></h2><p>As an example, we will use the Gamma expert to demonstrate how to write a customized expert function for any continuous distribution. For discrete distributions, the Poisson distribution is a good example, but we will omit the details here. In this illustrative example, we will go through the source code of Gamma Expert (available <a href="https://github.com/sparktseung/LRMoE.jl/blob/main/src/experts/continuous/gamma.jl">here</a>) to see what is needed to add a customized expert function.</p><p>Before starting, we create a new source code file <code>gamma.jl</code> for Gamma expert, and  put it in the corresponding folder, i.e. <code>src/experts/continuous</code>.</p><h3 id="Defining-a-struct"><a class="docs-heading-anchor" href="#Defining-a-struct">Defining a struct</a><a id="Defining-a-struct-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-struct" title="Permalink"></a></h3><p>The first step is to define the Gamma expert function and some basic and common functions shared by all experts. This corresponds to the first block of the source code. The details are quite similar to  adding a customized distribution to <code>Distributions.jl</code>, including defining the new <code>GammaExpert</code> as a sub-type of <code>NonZIContinuousExpert</code>,  some constructors and conversions of parameters.</p><pre><code class="language-julia hljs">struct GammaExpert{T&lt;:Real} &lt;: NonZIContinuousExpert
    k::T
    θ::T
    GammaExpert{T}(k::T, θ::T) where {T&lt;:Real} = new{T}(k, θ)
end

function GammaExpert(k::T, θ::T; check_args=true) where {T &lt;: Real}
    check_args &amp;&amp; @check_args(GammaExpert, k &gt;= zero(k) &amp;&amp; θ &gt; zero(θ))
    return GammaExpert{T}(k, θ)
end

## Outer constructors
GammaExpert(k::Real, θ::Real) = GammaExpert(promote(k, θ)...)
GammaExpert(k::Integer, θ::Integer) = GammaExpert(float(k), float(θ))
GammaExpert() = GammaExpert(1.0, 1.0)

## Conversion
function convert(::Type{GammaExpert{T}}, k::S, θ::S) where {T &lt;: Real, S &lt;: Real}
    GammaExpert(T(k), T(θ))
end
function convert(::Type{GammaExpert{T}}, d::GammaExpert{S}) where {T &lt;: Real, S &lt;: Real}
    GammaExpert(T(d.k), T(d.θ), check_args=false)
end
copy(d::GammaExpert) = GammaExpert(d.k, d.θ, check_args=false)</code></pre><h3 id="Exporting-the-expert-function"><a class="docs-heading-anchor" href="#Exporting-the-expert-function">Exporting the expert function</a><a id="Exporting-the-expert-function-1"></a><a class="docs-heading-anchor-permalink" href="#Exporting-the-expert-function" title="Permalink"></a></h3><p>This step should technically be at the very end, but we introduce it here to facilitate testing during development. In order for the expert function to be accessible to the user, it should be exported by modifying the files <code>src/experts/expert.jl</code> and <code>src/LRMoE.jl</code>: In the former, <code>gamma</code> is added to <code>contintous_experts</code> so that the source file <code>src/experts/continuous/gamma.jl</code> is included; In the latter, <code>GammaExpert</code> is exported so that the gamma expert function is accessible outside of the package.</p><h3 id="Basic-and-additional-functions"><a class="docs-heading-anchor" href="#Basic-and-additional-functions">Basic and additional functions</a><a id="Basic-and-additional-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-and-additional-functions" title="Permalink"></a></h3><p>For all expert functions, there are a number of basic functions absolutely needed for using the package. In addition, some functions may be omitted (e.g. calculating limited expected value) if they are not relevant to the modeling problem at hand.</p><p><strong>Basic probability functions</strong>: <code>pdf</code>, <code>logpdf</code>, <code>cdf</code> and <code>logcdf</code>. These are used for calculating the loglikelihood of the model. Notice that for <code>logpdf</code> etc., we have directly used the corresponding functions in <code>Distributions.jl</code> since the Gamma distribution is already implemented there. If this is not the case, the user can also add a new distribution type following the guide in <code>Distributions.jl</code>, and add the source code to the folder <code>src/experts/add_dist</code>.</p><pre><code class="language-julia hljs">## Loglikelihood of Expert
logpdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? -Inf : Distributions.logpdf.(Distributions.Gamma(d.k, d.θ), x...)
pdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? 0.0 : Distributions.pdf.(Distributions.Gamma(d.k, d.θ), x...)
logcdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? -Inf : Distributions.logcdf.(Distributions.Gamma(d.k, d.θ), x...)
cdf(d::GammaExpert, x...) = (d.k &lt; 1 &amp;&amp; x... &lt;= 0.0) ? 0.0 : Distributions.cdf.(Distributions.Gamma(d.k, d.θ), x...)</code></pre><p><strong>Parameters and initialization</strong>: The following functions are necessary for calling the functions to initialize parameters (e.g. <code>cmm_init_params</code>).</p><p>In the following <code>params_init</code> function, we assume a vector of observations <code>y</code>, and match the first two moments to solve for the parameters of a gamma distribution. Notice that the function should return an expert function, not the parameter values. Also, an empty expert should also be added to the corresponding list in <code>src/paramsinit.jl</code>. In this case, <code>GammaExpert()</code> is added to <code>_default_expert_continuous</code>.</p><p>The function <code>ks_distance</code> is used to select an initialization of expert which has the lowest test statistics for the Kolmogorov-Smirnov test, in other words, the K-S distance is minimized. The <code>ks_distance</code> simply calculates the test statistics given a vector of observations <code>y</code> and an expert function <code>GammaExpert</code> (i.e. to see if the observations <code>y</code> come from a Gamma distribution).</p><pre><code class="language-julia hljs">## Parameters
params(d::GammaExpert) = (d.k, d.θ)
function params_init(y, d::GammaExpert)
    pos_idx = (y .&gt; 0.0)
    μ, σ2 = mean(y[pos_idx]), var(y[pos_idx])
    θ_init = σ2/μ
    k_init = μ/θ_init
    if isnan(θ_init) || isnan(k_init)
        return GammaExpert()
    else
        return GammaExpert(k_init, θ_init)
    end
end

## KS stats for parameter initialization
function ks_distance(y, d::GammaExpert)
    p_zero = sum(y .== 0.0) / sum(y .&gt;= 0.0)
    return max(abs(p_zero-0.0), (1-0.0)*HypothesisTests.ksstats(y[y .&gt; 0.0], Distributions.Gamma(d.k, d.θ))[2])
end</code></pre><p><strong>Simulation</strong>: A simulator is also needed, which simulates a vector of length <code>sample_size</code> from the expert function.</p><pre><code class="language-julia hljs">## Simululation
sim_expert(d::GammaExpert, sample_size) = Distributions.rand(Distributions.Gamma(d.k, d.θ), sample_size)</code></pre><p><strong>Penalty on parameters</strong>: This is also required. When fitting mixture models, the EM algorithm may converge to a spurious model with extremely large or small parameter values, which is undesirable for a number of reasons (e.g. giving infinite likelihood, or straight up a NaN error). Hence, a penalty is imposed for these extreme cases. In implementation, we essentially assume the parameters have a prior distribution described by some hyperparameters. Consequently, the EM step is essentially maximizing a posterior loglikelihood.</p><p>As a rule of thumb, we assume a Gamma prior for positive parameters and a Normal prior for real parameters. For example, the penalty terms for Gamma experts are coded as follows. </p><pre><code class="language-julia hljs">## penalty
penalty_init(d::GammaExpert) = [2.0 10.0 2.0 10.0]
no_penalty_init(d::GammaExpert) = [1.0 Inf 1.0 Inf]
penalize(d::GammaExpert, p) = (p[1]-1)*log(d.k) - d.k/p[2] + (p[3]-1)*log(d.θ) - d.θ/p[4]</code></pre><p>In the function <code>penalize</code>, the hyperparameters are given as a vector <code>p</code>. We assume the shape parameter <code>k</code> of the Gamma expert follows a Gamma prior distribution with shape <code>p[1]</code> and scale <code>p[2]</code>. Analogously, the scale parameter <code>θ</code> of the Gamma expert follows a Gamma prior distribution with shape <code>p[3]</code> and scale <code>p[4]</code>. The <code>penalize</code> function calculates the prior logpdf of the parameters, excluding the constant terms since they are irrelevant to the EM algorithm.</p><p>The functions <code>penalty_init</code> initializes some default hyperparameters, if they are not given by the user. Similarly, <code>no_penalty_init</code> speficies hyperparameters which poses no penalty, as plugging ion <code>p = [1.0 Inf 1.0 Inf]</code> into the <code>penalize</code> function yields zero. Still, it is recommended to always use some penalty in application to avoid the issue of spurious models mentioned above.</p><p>Note that the penalty term should be subtracted from the loglikelihood when implementing the M-step of the EM algorithm (see below).</p><p><strong>Miscellaneous functions</strong>: There are a number of miscellaneous functions implemented for the expert function as shown below. They are mainly used in  predictive functions such as <code>predict_mean_prior</code>. It is recommended to code them as well when adding a new expert function, but (some or all of) these functions can be optional if the user only wants to fit an LRMoE model.</p><pre><code class="language-julia hljs">## statistics
mean(d::GammaExpert) = mean(Distributions.Gamma(d.k, d.θ))
var(d::GammaExpert) = var(Distributions.Gamma(d.k, d.θ))
quantile(d::GammaExpert, p) = quantile(Distributions.Gamma(d.k, d.θ), p)
lev(d::GammaExpert, u) = d.θ*d.k*gamma_inc(float(d.k+1), u/d.θ, 0)[1] + u*(1-gamma_inc(float(d.k), u/d.θ,0)[1])
excess(d::GammaExpert, u) = mean(d) - lev(d, u)</code></pre><h3 id="M-Step:-exact-observation"><a class="docs-heading-anchor" href="#M-Step:-exact-observation">M-Step: exact observation</a><a id="M-Step:-exact-observation-1"></a><a class="docs-heading-anchor-permalink" href="#M-Step:-exact-observation" title="Permalink"></a></h3><p>The next step is to implement the M-step of the EM algorithm, which is given in Section 3.2 of <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3740061">Fung et al. (2019)</a>. Notice that the cited paper considers the issue of data truncation and censoring, but as a first step, we will just assume all data are observed exactly. Data truncation and censoring are dealt with afterwards.</p><p>The M-step with exact observation is carried out by the function <code>EM_M_expert_exact</code> in the source code. Note that the function name and arguments should not be altered, since it is referenced in the main fitting function of the package.</p><p>In short, the goal is to maximize the objective function  <code>z_e_obs</code> * <span>$LL$</span>, where <span>$LL$</span> is the loglikelihood of the expert <code>d</code> when observing a vector <code>ye</code>. If the function argument <code>penalty</code> is true, then a penalty term given by hyperparameters <code>pen_params_jk</code> (see also above) is subtracted from the objective function. The function argument <code>expert_ll_pos</code> is a legacy and irrelevant to the M-step when observations <code>ye</code> are exact.</p><p>For Gamma expert, we are maximizing with respect to <span>$k$</span> and <span>$\lambda$</span> (without penalty) the objective function <code>z_e_obs</code> multiplied by</p><p><span>$LL = \sum_{i = 1}^{n} (k-1)\log(y_i) - y_i/k - \log(\Gamma(k)) - k\log(\lambda)$</span>.</p><p>The optimization is done by calling <code>minimizer</code> in <code>Optim.jl</code>, which is ommited in this document. Penalty can also be added in the objective function if the function argument <code>penalty</code> is set to <code>true</code>.</p><p>Finally, the <code>EM_M_expert_exact</code> returns a Gamma expert object containing the updated parameters, thus completing the M-step.</p><h3 id="M-Step:-censored-and-truncated-observation"><a class="docs-heading-anchor" href="#M-Step:-censored-and-truncated-observation">M-Step: censored and truncated observation</a><a id="M-Step:-censored-and-truncated-observation-1"></a><a class="docs-heading-anchor-permalink" href="#M-Step:-censored-and-truncated-observation" title="Permalink"></a></h3><p>One important feature of this package is to deal with censored and truncated data, which is common both in and outside actuarial contexts. In this case, the loglikelihood is incomplete, in the sense that <span>$y_i$</span> above is not known exactly, leading to an additional E-step before the M-step.</p><p>In particular, the M-step with data censoring and truncation is done by the  function <code>EM_M_step</code>, which takes a few more arguments compared with  <code>EM_M_expert_exact</code>. Again, the function name and arguments should not be altered.</p><p>Recall that we assume the obsercations are truncated between <code>tl</code> and <code>tu</code>, as well as censored between <code>yl</code> and <code>yu</code>. These lower and upper bounds are needed for the M-step.</p><p>Censored data points are in the observed dataset. For all the censored observation <code>y</code>, we don&#39;t know their exact values, but only know that they are between  <code>yl</code> and <code>yu</code>. Hence, for those observations, we should take the expected value of the loglikelihood, further normalizing them by the probability of falling within this interval (which is equal to <code>exp.(-expert_ll_pos)</code>).</p><p>For the Gamma expert, we refer to the equation of <span>$LL$</span> above: the uncertain terms are <span>$\log(y_i)$</span> and <span>$y_i$</span>, so we should compute their conditional expectation, given that the exact observation is between <code>yl</code> and <code>yu</code>. This corresponds to some numerical integration procedures in the source code. Note that the conditional expectation should be computed with respect to the probability measure implied by the old (i.e. not yet updated) parameters.</p><p>A similar remark can be made about truncated observations, which are not present in the dataset due to truncation. Those are either smaller than the lower bound of truncation <code>tl</code>, or larger than the upper bound of truncation <code>tu</code>. In addition, the function argument <code>k_e</code> is equal to the expected number of lost observations due to truncation, which should also be multiplied to the conditional expectation of loglikelihood.</p><p>To be more specific, we also numerically integrate <span>$\log(y_i)$</span> and <span>$y_i$</span> in <span>$LL$</span>, but from <code>0</code> to <code>tl</code> and from <code>tu</code> to <code>Inf</code>. Then, we normalize it by the probability <code>exp.(-expert_tn_bar_pos)</code> to obtain the conditional expectation. Finally, the loglikelihood is further multiplied by <code>k_e</code> to account for all unobserved data points due to truncation.</p><p>Finally, the loglikelihood of truncated observations is added to the objective function for optimization.</p><h2 id="Notes-and-tips"><a class="docs-heading-anchor" href="#Notes-and-tips">Notes and tips</a><a id="Notes-and-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-and-tips" title="Permalink"></a></h2><p>There are quite a few things to note when adding a customized expert function.</p><ul><li><p>Exact observations: If the problem at hand only concerns exact observations, then the user can write the <code>EM_M_exact</code> function only.</p></li><li><p>Speeding up numerical integration: In <code>EM_M_step</code>, numerical integration for certain expert functions can take a long time. In the <code>gamma.jl</code> example, the author has first looked up for unique lower and upper bounds, and only integrate using those pairs. Then, the numerical integration is mapped to the original dataset. Users are advised to also take this approach, which can be done by conveniently copying and modifying the source code of <code>gamma.jl</code>.</p></li><li><p>Optimization constraits: Some expert functions pose constrants on the parameters, e.g. the parameters of Gamma experts should be positive. However, constrained optimization can be computationally slow. In <code>gamma.jl</code>, we have used a log transformation, so that the optimization procedure <code>Optim.optimize</code> is unconstrained. Also, specifying a small search interval speeds things up.</p></li><li><p>Zero inflation: For zero-inflated expert functions, the M-step should only take in positive observations for continuous experts, but all non-negative observations for discrete experts. See <code>gamma.jl</code> and <code>poisson.jl</code> for a comparison.</p></li></ul><p>For further questions and tips when customizing expert functions, please contact the author on github.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/sim_fit/simulate_fit/">« Fitting Function</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 19 June 2023 10:50">Monday 19 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
